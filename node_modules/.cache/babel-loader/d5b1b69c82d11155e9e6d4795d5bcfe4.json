{"ast":null,"code":"// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\"use strict\";\n\n(() => {\n  const enosys = () => {\n    const err = new Error(\"not implemented\");\n    err.code = \"ENOSYS\";\n    return err;\n  }; // if (!globalThis.fs) {\n  // \tlet outputBuf = \"\";\n  // \tglobalThis.fs = {\n  // \t\tconstants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n  // \t\twriteSync(fd, buf) {\n  // \t\t\toutputBuf += decoder.decode(buf);\n  // \t\t\tconst nl = outputBuf.lastIndexOf(\"\\n\");\n  // \t\t\tif (nl != -1) {\n  // \t\t\t\tconsole.log(outputBuf.substr(0, nl));\n  // \t\t\t\toutputBuf = outputBuf.substr(nl + 1);\n  // \t\t\t}\n  // \t\t\treturn buf.length;\n  // \t\t},\n  // \t\twrite(fd, buf, offset, length, position, callback) {\n  // \t\t\tif (offset !== 0 || length !== buf.length || position !== null) {\n  // \t\t\t\tcallback(enosys());\n  // \t\t\t\treturn;\n  // \t\t\t}\n  // \t\t\tconst n = this.writeSync(fd, buf);\n  // \t\t\tcallback(null, n);\n  // \t\t},\n  // \t\tchmod(path, mode, callback) { callback(enosys()); },\n  // \t\tchown(path, uid, gid, callback) { callback(enosys()); },\n  // \t\tclose(fd, callback) { callback(enosys()); },\n  // \t\tfchmod(fd, mode, callback) { callback(enosys()); },\n  // \t\tfchown(fd, uid, gid, callback) { callback(enosys()); },\n  // \t\tfstat(fd, callback) { callback(enosys()); },\n  // \t\tfsync(fd, callback) { callback(null); },\n  // \t\tftruncate(fd, length, callback) { callback(enosys()); },\n  // \t\tlchown(path, uid, gid, callback) { callback(enosys()); },\n  // \t\tlink(path, link, callback) { callback(enosys()); },\n  // \t\tlstat(path, callback) { callback(enosys()); },\n  // \t\tmkdir(path, perm, callback) { callback(enosys()); },\n  // \t\topen(path, flags, mode, callback) { callback(enosys()); },\n  // \t\tread(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n  // \t\treaddir(path, callback) { callback(enosys()); },\n  // \t\treadlink(path, callback) { callback(enosys()); },\n  // \t\trename(from, to, callback) { callback(enosys()); },\n  // \t\trmdir(path, callback) { callback(enosys()); },\n  // \t\tstat(path, callback) { callback(enosys()); },\n  // \t\tsymlink(path, link, callback) { callback(enosys()); },\n  // \t\ttruncate(path, length, callback) { callback(enosys()); },\n  // \t\tunlink(path, callback) { callback(enosys()); },\n  // \t\tutimes(path, atime, mtime, callback) { callback(enosys()); },\n  // \t};\n  // }\n  // if (!globalThis.process) {\n  // \tglobalThis.process = {\n  // \t\tgetuid() { return -1; },\n  // \t\tgetgid() { return -1; },\n  // \t\tgeteuid() { return -1; },\n  // \t\tgetegid() { return -1; },\n  // \t\tgetgroups() { throw enosys(); },\n  // \t\tpid: -1,\n  // \t\tppid: -1,\n  // \t\tumask() { throw enosys(); },\n  // \t\tcwd() { throw enosys(); },\n  // \t\tchdir() { throw enosys(); },\n  // \t}\n  // }\n  // if (!globalThis.crypto) {\n  // \tthrow new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\n  // }\n  // if (!globalThis.performance) {\n  // \tthrow new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\n  // }\n  // if (!globalThis.TextEncoder) {\n  // \tthrow new Error(\"globalThis.TextEncoder is not available, polyfill required\");\n  // }\n  // if (!globalThis.TextDecoder) {\n  // \tthrow new Error(\"globalThis.TextDecoder is not available, polyfill required\");\n  // }\n\n\n  const encoder = new TextEncoder(\"utf-8\");\n  const decoder = new TextDecoder(\"utf-8\");\n  globalThis.Go = class {\n    constructor() {\n      this.argv = [\"js\"];\n      this.env = {};\n\n      this.exit = code => {\n        if (code !== 0) {\n          console.warn(\"exit code:\", code);\n        }\n      };\n\n      this._exitPromise = new Promise(resolve => {\n        this._resolveExitPromise = resolve;\n      });\n      this._pendingEvent = null;\n      this._scheduledTimeouts = new Map();\n      this._nextCallbackTimeoutID = 1;\n\n      const setInt64 = (addr, v) => {\n        this.mem.setUint32(addr + 0, v, true);\n        this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n      };\n\n      const getInt64 = addr => {\n        const low = this.mem.getUint32(addr + 0, true);\n        const high = this.mem.getInt32(addr + 4, true);\n        return low + high * 4294967296;\n      };\n\n      const loadValue = addr => {\n        const f = this.mem.getFloat64(addr, true);\n\n        if (f === 0) {\n          return undefined;\n        }\n\n        if (!isNaN(f)) {\n          return f;\n        }\n\n        const id = this.mem.getUint32(addr, true);\n        return this._values[id];\n      };\n\n      const storeValue = (addr, v) => {\n        const nanHead = 0x7FF80000;\n\n        if (typeof v === \"number\" && v !== 0) {\n          if (isNaN(v)) {\n            this.mem.setUint32(addr + 4, nanHead, true);\n            this.mem.setUint32(addr, 0, true);\n            return;\n          }\n\n          this.mem.setFloat64(addr, v, true);\n          return;\n        }\n\n        if (v === undefined) {\n          this.mem.setFloat64(addr, 0, true);\n          return;\n        }\n\n        let id = this._ids.get(v);\n\n        if (id === undefined) {\n          id = this._idPool.pop();\n\n          if (id === undefined) {\n            id = this._values.length;\n          }\n\n          this._values[id] = v;\n          this._goRefCounts[id] = 0;\n\n          this._ids.set(v, id);\n        }\n\n        this._goRefCounts[id]++;\n        let typeFlag = 0;\n\n        switch (typeof v) {\n          case \"object\":\n            if (v !== null) {\n              typeFlag = 1;\n            }\n\n            break;\n\n          case \"string\":\n            typeFlag = 2;\n            break;\n\n          case \"symbol\":\n            typeFlag = 3;\n            break;\n\n          case \"function\":\n            typeFlag = 4;\n            break;\n        }\n\n        this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n        this.mem.setUint32(addr, id, true);\n      };\n\n      const loadSlice = addr => {\n        const array = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n      };\n\n      const loadSliceOfValues = addr => {\n        const array = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        const a = new Array(len);\n\n        for (let i = 0; i < len; i++) {\n          a[i] = loadValue(array + i * 8);\n        }\n\n        return a;\n      };\n\n      const loadString = addr => {\n        const saddr = getInt64(addr + 0);\n        const len = getInt64(addr + 8);\n        return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n      };\n\n      const timeOrigin = Date.now() - performance.now();\n      this.importObject = {\n        go: {\n          // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n          // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n          // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n          // This changes the SP, thus we have to update the SP used by the imported function.\n          // func wasmExit(code int32)\n          \"runtime.wasmExit\": sp => {\n            sp >>>= 0;\n            const code = this.mem.getInt32(sp + 8, true);\n            this.exited = true;\n            delete this._inst;\n            delete this._values;\n            delete this._goRefCounts;\n            delete this._ids;\n            delete this._idPool;\n            this.exit(code);\n          },\n          // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n          \"runtime.wasmWrite\": sp => {\n            sp >>>= 0;\n            const fd = getInt64(sp + 8);\n            const p = getInt64(sp + 16);\n            const n = this.mem.getInt32(sp + 24, true);\n            fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n          },\n          // func resetMemoryDataView()\n          \"runtime.resetMemoryDataView\": sp => {\n            sp >>>= 0;\n            this.mem = new DataView(this._inst.exports.mem.buffer);\n          },\n          // func nanotime1() int64\n          \"runtime.nanotime1\": sp => {\n            sp >>>= 0;\n            setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n          },\n          // func walltime() (sec int64, nsec int32)\n          \"runtime.walltime\": sp => {\n            sp >>>= 0;\n            const msec = new Date().getTime();\n            setInt64(sp + 8, msec / 1000);\n            this.mem.setInt32(sp + 16, msec % 1000 * 1000000, true);\n          },\n          // func scheduleTimeoutEvent(delay int64) int32\n          \"runtime.scheduleTimeoutEvent\": sp => {\n            sp >>>= 0;\n            const id = this._nextCallbackTimeoutID;\n            this._nextCallbackTimeoutID++;\n\n            this._scheduledTimeouts.set(id, setTimeout(() => {\n              this._resume();\n\n              while (this._scheduledTimeouts.has(id)) {\n                // for some reason Go failed to register the timeout event, log and try again\n                // (temporary workaround for https://github.com/golang/go/issues/28975)\n                console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n\n                this._resume();\n              }\n            }, getInt64(sp + 8) + 1 // setTimeout has been seen to fire up to 1 millisecond early\n            ));\n\n            this.mem.setInt32(sp + 16, id, true);\n          },\n          // func clearTimeoutEvent(id int32)\n          \"runtime.clearTimeoutEvent\": sp => {\n            sp >>>= 0;\n            const id = this.mem.getInt32(sp + 8, true);\n            clearTimeout(this._scheduledTimeouts.get(id));\n\n            this._scheduledTimeouts.delete(id);\n          },\n          // func getRandomData(r []byte)\n          \"runtime.getRandomData\": sp => {\n            sp >>>= 0;\n            crypto.getRandomValues(loadSlice(sp + 8));\n          },\n          // func finalizeRef(v ref)\n          \"syscall/js.finalizeRef\": sp => {\n            sp >>>= 0;\n            const id = this.mem.getUint32(sp + 8, true);\n            this._goRefCounts[id]--;\n\n            if (this._goRefCounts[id] === 0) {\n              const v = this._values[id];\n              this._values[id] = null;\n\n              this._ids.delete(v);\n\n              this._idPool.push(id);\n            }\n          },\n          // func stringVal(value string) ref\n          \"syscall/js.stringVal\": sp => {\n            sp >>>= 0;\n            storeValue(sp + 24, loadString(sp + 8));\n          },\n          // func valueGet(v ref, p string) ref\n          \"syscall/js.valueGet\": sp => {\n            sp >>>= 0;\n            const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n            sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n            storeValue(sp + 32, result);\n          },\n          // func valueSet(v ref, p string, x ref)\n          \"syscall/js.valueSet\": sp => {\n            sp >>>= 0;\n            Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n          },\n          // func valueDelete(v ref, p string)\n          \"syscall/js.valueDelete\": sp => {\n            sp >>>= 0;\n            Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n          },\n          // func valueIndex(v ref, i int) ref\n          \"syscall/js.valueIndex\": sp => {\n            sp >>>= 0;\n            storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n          },\n          // valueSetIndex(v ref, i int, x ref)\n          \"syscall/js.valueSetIndex\": sp => {\n            sp >>>= 0;\n            Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n          },\n          // func valueCall(v ref, m string, args []ref) (ref, bool)\n          \"syscall/js.valueCall\": sp => {\n            sp >>>= 0;\n\n            try {\n              const v = loadValue(sp + 8);\n              const m = Reflect.get(v, loadString(sp + 16));\n              const args = loadSliceOfValues(sp + 32);\n              const result = Reflect.apply(m, v, args);\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 56, result);\n              this.mem.setUint8(sp + 64, 1);\n            } catch (err) {\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 56, err);\n              this.mem.setUint8(sp + 64, 0);\n            }\n          },\n          // func valueInvoke(v ref, args []ref) (ref, bool)\n          \"syscall/js.valueInvoke\": sp => {\n            sp >>>= 0;\n\n            try {\n              const v = loadValue(sp + 8);\n              const args = loadSliceOfValues(sp + 16);\n              const result = Reflect.apply(v, undefined, args);\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 40, result);\n              this.mem.setUint8(sp + 48, 1);\n            } catch (err) {\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 40, err);\n              this.mem.setUint8(sp + 48, 0);\n            }\n          },\n          // func valueNew(v ref, args []ref) (ref, bool)\n          \"syscall/js.valueNew\": sp => {\n            sp >>>= 0;\n\n            try {\n              const v = loadValue(sp + 8);\n              const args = loadSliceOfValues(sp + 16);\n              const result = Reflect.construct(v, args);\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 40, result);\n              this.mem.setUint8(sp + 48, 1);\n            } catch (err) {\n              sp = this._inst.exports.getsp() >>> 0; // see comment above\n\n              storeValue(sp + 40, err);\n              this.mem.setUint8(sp + 48, 0);\n            }\n          },\n          // func valueLength(v ref) int\n          \"syscall/js.valueLength\": sp => {\n            sp >>>= 0;\n            setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n          },\n          // valuePrepareString(v ref) (ref, int)\n          \"syscall/js.valuePrepareString\": sp => {\n            sp >>>= 0;\n            const str = encoder.encode(String(loadValue(sp + 8)));\n            storeValue(sp + 16, str);\n            setInt64(sp + 24, str.length);\n          },\n          // valueLoadString(v ref, b []byte)\n          \"syscall/js.valueLoadString\": sp => {\n            sp >>>= 0;\n            const str = loadValue(sp + 8);\n            loadSlice(sp + 16).set(str);\n          },\n          // func valueInstanceOf(v ref, t ref) bool\n          \"syscall/js.valueInstanceOf\": sp => {\n            sp >>>= 0;\n            this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n          },\n          // func copyBytesToGo(dst []byte, src ref) (int, bool)\n          \"syscall/js.copyBytesToGo\": sp => {\n            sp >>>= 0;\n            const dst = loadSlice(sp + 8);\n            const src = loadValue(sp + 32);\n\n            if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n              this.mem.setUint8(sp + 48, 0);\n              return;\n            }\n\n            const toCopy = src.subarray(0, dst.length);\n            dst.set(toCopy);\n            setInt64(sp + 40, toCopy.length);\n            this.mem.setUint8(sp + 48, 1);\n          },\n          // func copyBytesToJS(dst ref, src []byte) (int, bool)\n          \"syscall/js.copyBytesToJS\": sp => {\n            sp >>>= 0;\n            const dst = loadValue(sp + 8);\n            const src = loadSlice(sp + 16);\n\n            if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n              this.mem.setUint8(sp + 48, 0);\n              return;\n            }\n\n            const toCopy = src.subarray(0, dst.length);\n            dst.set(toCopy);\n            setInt64(sp + 40, toCopy.length);\n            this.mem.setUint8(sp + 48, 1);\n          },\n          \"debug\": value => {\n            console.log(value);\n          }\n        }\n      };\n    }\n\n    async run(instance) {\n      if (!(instance instanceof WebAssembly.Instance)) {\n        throw new Error(\"Go.run: WebAssembly.Instance expected\");\n      }\n\n      this._inst = instance;\n      this.mem = new DataView(this._inst.exports.mem.buffer);\n      this._values = [// JS values that Go currently has references to, indexed by reference id\n      NaN, 0, null, true, false, globalThis, this];\n      this._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n\n      this._ids = new Map([// mapping from JS values to reference ids\n      [0, 1], [null, 2], [true, 3], [false, 4], [globalThis, 5], [this, 6]]);\n      this._idPool = []; // unused ids that have been garbage collected\n\n      this.exited = false; // whether the Go program has exited\n      // Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n\n      let offset = 4096;\n\n      const strPtr = str => {\n        const ptr = offset;\n        const bytes = encoder.encode(str + \"\\0\");\n        new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n        offset += bytes.length;\n\n        if (offset % 8 !== 0) {\n          offset += 8 - offset % 8;\n        }\n\n        return ptr;\n      };\n\n      const argc = this.argv.length;\n      const argvPtrs = [];\n      this.argv.forEach(arg => {\n        argvPtrs.push(strPtr(arg));\n      });\n      argvPtrs.push(0);\n      const keys = Object.keys(this.env).sort();\n      keys.forEach(key => {\n        argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n      });\n      argvPtrs.push(0);\n      const argv = offset;\n      argvPtrs.forEach(ptr => {\n        this.mem.setUint32(offset, ptr, true);\n        this.mem.setUint32(offset + 4, 0, true);\n        offset += 8;\n      }); // The linker guarantees global data starts from at least wasmMinDataAddr.\n      // Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n\n      const wasmMinDataAddr = 4096 + 8192;\n\n      if (offset >= wasmMinDataAddr) {\n        throw new Error(\"total length of command line and environment variables exceeds limit\");\n      }\n\n      this._inst.exports.run(argc, argv);\n\n      if (this.exited) {\n        this._resolveExitPromise();\n      }\n\n      await this._exitPromise;\n    }\n\n    _resume() {\n      if (this.exited) {\n        throw new Error(\"Go program has already exited\");\n      }\n\n      this._inst.exports.resume();\n\n      if (this.exited) {\n        this._resolveExitPromise();\n      }\n    }\n\n    _makeFuncWrapper(id) {\n      const go = this;\n      return function () {\n        const event = {\n          id: id,\n          this: this,\n          args: arguments\n        };\n        go._pendingEvent = event;\n\n        go._resume();\n\n        return event.result;\n      };\n    }\n\n  };\n})();","map":{"version":3,"names":["enosys","err","Error","code","encoder","TextEncoder","decoder","TextDecoder","globalThis","Go","constructor","argv","env","exit","console","warn","_exitPromise","Promise","resolve","_resolveExitPromise","_pendingEvent","_scheduledTimeouts","Map","_nextCallbackTimeoutID","setInt64","addr","v","mem","setUint32","Math","floor","getInt64","low","getUint32","high","getInt32","loadValue","f","getFloat64","undefined","isNaN","id","_values","storeValue","nanHead","setFloat64","_ids","get","_idPool","pop","length","_goRefCounts","set","typeFlag","loadSlice","array","len","Uint8Array","_inst","exports","buffer","loadSliceOfValues","a","Array","i","loadString","saddr","decode","DataView","timeOrigin","Date","now","performance","importObject","go","sp","exited","fd","p","n","fs","writeSync","msec","getTime","setInt32","setTimeout","_resume","has","clearTimeout","delete","crypto","getRandomValues","push","result","Reflect","getsp","deleteProperty","m","args","apply","setUint8","construct","parseInt","str","encode","String","dst","src","Uint8ClampedArray","toCopy","subarray","value","log","run","instance","WebAssembly","Instance","NaN","fill","Infinity","offset","strPtr","ptr","bytes","argc","argvPtrs","forEach","arg","keys","Object","sort","key","wasmMinDataAddr","resume","_makeFuncWrapper","event","this","arguments"],"sources":["/home/johan/dev/github/colonyos/dashboard/dashboard/src/colonies/crypto/wasm_exec.js"],"sourcesContent":["// Copyright 2018 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n\"use strict\";\n\n(() => {\n    const enosys = () => {\n        const err = new Error(\"not implemented\");\n        err.code = \"ENOSYS\";\n        return err;\n    };\n\n    // if (!globalThis.fs) {\n    // \tlet outputBuf = \"\";\n    // \tglobalThis.fs = {\n    // \t\tconstants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 }, // unused\n    // \t\twriteSync(fd, buf) {\n    // \t\t\toutputBuf += decoder.decode(buf);\n    // \t\t\tconst nl = outputBuf.lastIndexOf(\"\\n\");\n    // \t\t\tif (nl != -1) {\n    // \t\t\t\tconsole.log(outputBuf.substr(0, nl));\n    // \t\t\t\toutputBuf = outputBuf.substr(nl + 1);\n    // \t\t\t}\n    // \t\t\treturn buf.length;\n    // \t\t},\n    // \t\twrite(fd, buf, offset, length, position, callback) {\n    // \t\t\tif (offset !== 0 || length !== buf.length || position !== null) {\n    // \t\t\t\tcallback(enosys());\n    // \t\t\t\treturn;\n    // \t\t\t}\n    // \t\t\tconst n = this.writeSync(fd, buf);\n    // \t\t\tcallback(null, n);\n    // \t\t},\n    // \t\tchmod(path, mode, callback) { callback(enosys()); },\n    // \t\tchown(path, uid, gid, callback) { callback(enosys()); },\n    // \t\tclose(fd, callback) { callback(enosys()); },\n    // \t\tfchmod(fd, mode, callback) { callback(enosys()); },\n    // \t\tfchown(fd, uid, gid, callback) { callback(enosys()); },\n    // \t\tfstat(fd, callback) { callback(enosys()); },\n    // \t\tfsync(fd, callback) { callback(null); },\n    // \t\tftruncate(fd, length, callback) { callback(enosys()); },\n    // \t\tlchown(path, uid, gid, callback) { callback(enosys()); },\n    // \t\tlink(path, link, callback) { callback(enosys()); },\n    // \t\tlstat(path, callback) { callback(enosys()); },\n    // \t\tmkdir(path, perm, callback) { callback(enosys()); },\n    // \t\topen(path, flags, mode, callback) { callback(enosys()); },\n    // \t\tread(fd, buffer, offset, length, position, callback) { callback(enosys()); },\n    // \t\treaddir(path, callback) { callback(enosys()); },\n    // \t\treadlink(path, callback) { callback(enosys()); },\n    // \t\trename(from, to, callback) { callback(enosys()); },\n    // \t\trmdir(path, callback) { callback(enosys()); },\n    // \t\tstat(path, callback) { callback(enosys()); },\n    // \t\tsymlink(path, link, callback) { callback(enosys()); },\n    // \t\ttruncate(path, length, callback) { callback(enosys()); },\n    // \t\tunlink(path, callback) { callback(enosys()); },\n    // \t\tutimes(path, atime, mtime, callback) { callback(enosys()); },\n    // \t};\n    // }\n\n    // if (!globalThis.process) {\n    // \tglobalThis.process = {\n    // \t\tgetuid() { return -1; },\n    // \t\tgetgid() { return -1; },\n    // \t\tgeteuid() { return -1; },\n    // \t\tgetegid() { return -1; },\n    // \t\tgetgroups() { throw enosys(); },\n    // \t\tpid: -1,\n    // \t\tppid: -1,\n    // \t\tumask() { throw enosys(); },\n    // \t\tcwd() { throw enosys(); },\n    // \t\tchdir() { throw enosys(); },\n    // \t}\n    // }\n\n    // if (!globalThis.crypto) {\n    // \tthrow new Error(\"globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)\");\n    // }\n\n    // if (!globalThis.performance) {\n    // \tthrow new Error(\"globalThis.performance is not available, polyfill required (performance.now only)\");\n    // }\n\n    // if (!globalThis.TextEncoder) {\n    // \tthrow new Error(\"globalThis.TextEncoder is not available, polyfill required\");\n    // }\n\n    // if (!globalThis.TextDecoder) {\n    // \tthrow new Error(\"globalThis.TextDecoder is not available, polyfill required\");\n    // }\n\n    const encoder = new TextEncoder(\"utf-8\");\n    const decoder = new TextDecoder(\"utf-8\");\n\n    globalThis.Go = class {\n        constructor() {\n            this.argv = [\"js\"];\n            this.env = {};\n            this.exit = (code) => {\n                if (code !== 0) {\n                    console.warn(\"exit code:\", code);\n                }\n            };\n            this._exitPromise = new Promise((resolve) => {\n                this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = new Map();\n            this._nextCallbackTimeoutID = 1;\n\n            const setInt64 = (addr, v) => {\n                this.mem.setUint32(addr + 0, v, true);\n                this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            }\n\n            const getInt64 = (addr) => {\n                const low = this.mem.getUint32(addr + 0, true);\n                const high = this.mem.getInt32(addr + 4, true);\n                return low + high * 4294967296;\n            }\n\n            const loadValue = (addr) => {\n                const f = this.mem.getFloat64(addr, true);\n                if (f === 0) {\n                    return undefined;\n                }\n                if (!isNaN(f)) {\n                    return f;\n                }\n\n                const id = this.mem.getUint32(addr, true);\n                return this._values[id];\n            }\n\n            const storeValue = (addr, v) => {\n                const nanHead = 0x7FF80000;\n\n                if (typeof v === \"number\" && v !== 0) {\n                    if (isNaN(v)) {\n                        this.mem.setUint32(addr + 4, nanHead, true);\n                        this.mem.setUint32(addr, 0, true);\n                        return;\n                    }\n                    this.mem.setFloat64(addr, v, true);\n                    return;\n                }\n\n                if (v === undefined) {\n                    this.mem.setFloat64(addr, 0, true);\n                    return;\n                }\n\n                let id = this._ids.get(v);\n                if (id === undefined) {\n                    id = this._idPool.pop();\n                    if (id === undefined) {\n                        id = this._values.length;\n                    }\n                    this._values[id] = v;\n                    this._goRefCounts[id] = 0;\n                    this._ids.set(v, id);\n                }\n                this._goRefCounts[id]++;\n                let typeFlag = 0;\n                switch (typeof v) {\n                    case \"object\":\n                        if (v !== null) {\n                            typeFlag = 1;\n                        }\n                        break;\n                    case \"string\":\n                        typeFlag = 2;\n                        break;\n                    case \"symbol\":\n                        typeFlag = 3;\n                        break;\n                    case \"function\":\n                        typeFlag = 4;\n                        break;\n                }\n                this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n                this.mem.setUint32(addr, id, true);\n            }\n\n            const loadSlice = (addr) => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            }\n\n            const loadSliceOfValues = (addr) => {\n                const array = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                const a = new Array(len);\n                for (let i = 0; i < len; i++) {\n                    a[i] = loadValue(array + i * 8);\n                }\n                return a;\n            }\n\n            const loadString = (addr) => {\n                const saddr = getInt64(addr + 0);\n                const len = getInt64(addr + 8);\n                return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            }\n\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n                go: {\n                    // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n                    // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n                    // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n                    // This changes the SP, thus we have to update the SP used by the imported function.\n\n                    // func wasmExit(code int32)\n                    \"runtime.wasmExit\": (sp) => {\n                        sp >>>= 0;\n                        const code = this.mem.getInt32(sp + 8, true);\n                        this.exited = true;\n                        delete this._inst;\n                        delete this._values;\n                        delete this._goRefCounts;\n                        delete this._ids;\n                        delete this._idPool;\n                        this.exit(code);\n                    },\n\n                    // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n                    \"runtime.wasmWrite\": (sp) => {\n                        sp >>>= 0;\n                        const fd = getInt64(sp + 8);\n                        const p = getInt64(sp + 16);\n                        const n = this.mem.getInt32(sp + 24, true);\n                        fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                    },\n\n                    // func resetMemoryDataView()\n                    \"runtime.resetMemoryDataView\": (sp) => {\n                        sp >>>= 0;\n                        this.mem = new DataView(this._inst.exports.mem.buffer);\n                    },\n\n                    // func nanotime1() int64\n                    \"runtime.nanotime1\": (sp) => {\n                        sp >>>= 0;\n                        setInt64(sp + 8, (timeOrigin + performance.now()) * 1000000);\n                    },\n\n                    // func walltime() (sec int64, nsec int32)\n                    \"runtime.walltime\": (sp) => {\n                        sp >>>= 0;\n                        const msec = (new Date).getTime();\n                        setInt64(sp + 8, msec / 1000);\n                        this.mem.setInt32(sp + 16, (msec % 1000) * 1000000, true);\n                    },\n\n                    // func scheduleTimeoutEvent(delay int64) int32\n                    \"runtime.scheduleTimeoutEvent\": (sp) => {\n                        sp >>>= 0;\n                        const id = this._nextCallbackTimeoutID;\n                        this._nextCallbackTimeoutID++;\n                        this._scheduledTimeouts.set(id, setTimeout(\n                            () => {\n                                this._resume();\n                                while (this._scheduledTimeouts.has(id)) {\n                                    // for some reason Go failed to register the timeout event, log and try again\n                                    // (temporary workaround for https://github.com/golang/go/issues/28975)\n                                    console.warn(\"scheduleTimeoutEvent: missed timeout event\");\n                                    this._resume();\n                                }\n                            },\n                            getInt64(sp + 8) + 1, // setTimeout has been seen to fire up to 1 millisecond early\n                        ));\n                        this.mem.setInt32(sp + 16, id, true);\n                    },\n\n                    // func clearTimeoutEvent(id int32)\n                    \"runtime.clearTimeoutEvent\": (sp) => {\n                        sp >>>= 0;\n                        const id = this.mem.getInt32(sp + 8, true);\n                        clearTimeout(this._scheduledTimeouts.get(id));\n                        this._scheduledTimeouts.delete(id);\n                    },\n\n                    // func getRandomData(r []byte)\n                    \"runtime.getRandomData\": (sp) => {\n                        sp >>>= 0;\n                        crypto.getRandomValues(loadSlice(sp + 8));\n                    },\n\n                    // func finalizeRef(v ref)\n                    \"syscall/js.finalizeRef\": (sp) => {\n                        sp >>>= 0;\n                        const id = this.mem.getUint32(sp + 8, true);\n                        this._goRefCounts[id]--;\n                        if (this._goRefCounts[id] === 0) {\n                            const v = this._values[id];\n                            this._values[id] = null;\n                            this._ids.delete(v);\n                            this._idPool.push(id);\n                        }\n                    },\n\n                    // func stringVal(value string) ref\n                    \"syscall/js.stringVal\": (sp) => {\n                        sp >>>= 0;\n                        storeValue(sp + 24, loadString(sp + 8));\n                    },\n\n                    // func valueGet(v ref, p string) ref\n                    \"syscall/js.valueGet\": (sp) => {\n                        sp >>>= 0;\n                        const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                        sp = this._inst.exports.getsp() >>> 0; // see comment above\n                        storeValue(sp + 32, result);\n                    },\n\n                    // func valueSet(v ref, p string, x ref)\n                    \"syscall/js.valueSet\": (sp) => {\n                        sp >>>= 0;\n                        Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                    },\n\n                    // func valueDelete(v ref, p string)\n                    \"syscall/js.valueDelete\": (sp) => {\n                        sp >>>= 0;\n                        Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                    },\n\n                    // func valueIndex(v ref, i int) ref\n                    \"syscall/js.valueIndex\": (sp) => {\n                        sp >>>= 0;\n                        storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                    },\n\n                    // valueSetIndex(v ref, i int, x ref)\n                    \"syscall/js.valueSetIndex\": (sp) => {\n                        sp >>>= 0;\n                        Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                    },\n\n                    // func valueCall(v ref, m string, args []ref) (ref, bool)\n                    \"syscall/js.valueCall\": (sp) => {\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const m = Reflect.get(v, loadString(sp + 16));\n                            const args = loadSliceOfValues(sp + 32);\n                            const result = Reflect.apply(m, v, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 56, result);\n                            this.mem.setUint8(sp + 64, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 56, err);\n                            this.mem.setUint8(sp + 64, 0);\n                        }\n                    },\n\n                    // func valueInvoke(v ref, args []ref) (ref, bool)\n                    \"syscall/js.valueInvoke\": (sp) => {\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const args = loadSliceOfValues(sp + 16);\n                            const result = Reflect.apply(v, undefined, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, result);\n                            this.mem.setUint8(sp + 48, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, err);\n                            this.mem.setUint8(sp + 48, 0);\n                        }\n                    },\n\n                    // func valueNew(v ref, args []ref) (ref, bool)\n                    \"syscall/js.valueNew\": (sp) => {\n                        sp >>>= 0;\n                        try {\n                            const v = loadValue(sp + 8);\n                            const args = loadSliceOfValues(sp + 16);\n                            const result = Reflect.construct(v, args);\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, result);\n                            this.mem.setUint8(sp + 48, 1);\n                        } catch (err) {\n                            sp = this._inst.exports.getsp() >>> 0; // see comment above\n                            storeValue(sp + 40, err);\n                            this.mem.setUint8(sp + 48, 0);\n                        }\n                    },\n\n                    // func valueLength(v ref) int\n                    \"syscall/js.valueLength\": (sp) => {\n                        sp >>>= 0;\n                        setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                    },\n\n                    // valuePrepareString(v ref) (ref, int)\n                    \"syscall/js.valuePrepareString\": (sp) => {\n                        sp >>>= 0;\n                        const str = encoder.encode(String(loadValue(sp + 8)));\n                        storeValue(sp + 16, str);\n                        setInt64(sp + 24, str.length);\n                    },\n\n                    // valueLoadString(v ref, b []byte)\n                    \"syscall/js.valueLoadString\": (sp) => {\n                        sp >>>= 0;\n                        const str = loadValue(sp + 8);\n                        loadSlice(sp + 16).set(str);\n                    },\n\n                    // func valueInstanceOf(v ref, t ref) bool\n                    \"syscall/js.valueInstanceOf\": (sp) => {\n                        sp >>>= 0;\n                        this.mem.setUint8(sp + 24, (loadValue(sp + 8) instanceof loadValue(sp + 16)) ? 1 : 0);\n                    },\n\n                    // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                    \"syscall/js.copyBytesToGo\": (sp) => {\n                        sp >>>= 0;\n                        const dst = loadSlice(sp + 8);\n                        const src = loadValue(sp + 32);\n                        if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                            this.mem.setUint8(sp + 48, 0);\n                            return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                    },\n\n                    // func copyBytesToJS(dst ref, src []byte) (int, bool)\n                    \"syscall/js.copyBytesToJS\": (sp) => {\n                        sp >>>= 0;\n                        const dst = loadValue(sp + 8);\n                        const src = loadSlice(sp + 16);\n                        if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                            this.mem.setUint8(sp + 48, 0);\n                            return;\n                        }\n                        const toCopy = src.subarray(0, dst.length);\n                        dst.set(toCopy);\n                        setInt64(sp + 40, toCopy.length);\n                        this.mem.setUint8(sp + 48, 1);\n                    },\n\n                    \"debug\": (value) => {\n                        console.log(value);\n                    },\n                }\n            };\n        }\n\n        async run(instance) {\n            if (!(instance instanceof WebAssembly.Instance)) {\n                throw new Error(\"Go.run: WebAssembly.Instance expected\");\n            }\n            this._inst = instance;\n            this.mem = new DataView(this._inst.exports.mem.buffer);\n            this._values = [ // JS values that Go currently has references to, indexed by reference id\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this,\n            ];\n            this._goRefCounts = new Array(this._values.length).fill(Infinity); // number of references that Go has to a JS value, indexed by reference id\n            this._ids = new Map([ // mapping from JS values to reference ids\n                [0, 1],\n                [null, 2],\n                [true, 3],\n                [false, 4],\n                [globalThis, 5],\n                [this, 6],\n            ]);\n            this._idPool = [];   // unused ids that have been garbage collected\n            this.exited = false; // whether the Go program has exited\n\n            // Pass command line arguments and environment variables to WebAssembly by writing them to the linear memory.\n            let offset = 4096;\n\n            const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + \"\\0\");\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                    offset += 8 - (offset % 8);\n                }\n                return ptr;\n            };\n\n            const argc = this.argv.length;\n\n            const argvPtrs = [];\n            this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n            });\n            argvPtrs.push(0);\n\n            const keys = Object.keys(this.env).sort();\n            keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n            });\n            argvPtrs.push(0);\n\n            const argv = offset;\n            argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n            });\n\n            // The linker guarantees global data starts from at least wasmMinDataAddr.\n            // Keep in sync with cmd/link/internal/ld/data.go:wasmMinDataAddr.\n            const wasmMinDataAddr = 4096 + 8192;\n            if (offset >= wasmMinDataAddr) {\n                throw new Error(\"total length of command line and environment variables exceeds limit\");\n            }\n\n            this._inst.exports.run(argc, argv);\n            if (this.exited) {\n                this._resolveExitPromise();\n            }\n            await this._exitPromise;\n        }\n\n        _resume() {\n            if (this.exited) {\n                throw new Error(\"Go program has already exited\");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n                this._resolveExitPromise();\n            }\n        }\n\n        _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n                const event = { id: id, this: this, args: arguments };\n                go._pendingEvent = event;\n                go._resume();\n                return event.result;\n            };\n        }\n    }\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}